
// programme envoi température arduino

#include <stdlib.h>
#include <string.h>
#include <VirtualWire.h>
#include <OneWire.h>

#define ID 1 // a changer pour chaque appareil
#define BROCHE_ONEWIRE 7 
#define BROCHE_RADIO_DATA 12 // pin pour l'envoie des données
#define SPEED_DATA 2000 // vitesse envoie

/* Code de retour de la fonction getTemperature() */
enum DS18B20_RCODES {
  READ_OK,  // Lecture ok
  NO_SENSOR_FOUND,  // Pas de capteur
  INVALID_ADDRESS,  // Adresse reçue invalide
  INVALID_SENSOR  // Capteur invalide (pas un DS18B20)
};


/* Création de l'objet OneWire pour manipuler le bus 1-Wire */
OneWire ds(BROCHE_ONEWIRE);



void initRadioModuleSend();
void sendMessage(char *message);
byte getTemperature(float *temperature, byte reset_search);
int receveMessage( uint8_t buf[]);

void setup()
{
    Serial.begin(9600);    // Debugging only

    // Initialise pin
    pinMode(5, INPUT);
    pinMode(2, OUTPUT);
    
	//sync(timestamp) // to syncro the arduino
    initRadioModuleSend();
}


void loop()
{
    float temperature;
   
    /* Lit les températures des trois capteurs */
    if (getTemperature(&temperature, true) != READ_OK) {
      Serial.println(F("Erreur de lecture du capteur"));
    } else {
		char message[255]={0};
		sprintf(message,"{\"I\":%d,\"T\":%lf,\"D\":%d}",ID,temperature,now());
		sendMessage(message);
		
	}
	
}

void sendMessage(char *message){
	vw_send((uint8_t *)message, strlen(message));
	vw_wait_tx(); // Wait until the whole message is gone
}

void initRadioModuleSend(){
	vw_set_ptt_inverted(true);
	vw_set_tx_pin(BROCHE_RADIO_DATA);
	vw_setup(SPEED_DATA);// speed of data transfer Kbps
}

void initRadioModuleReceve(){
	initRadioModuleSend();
	vw_rx_start(); 
	
}

int receveMessage( uint8_t buf[]){ // buf[VW_MAX_MESSAGE_LEN]
	uint8_t buflen = VW_MAX_MESSAGE_LEN;

	if (vw_get_message(buf, &buflen)) // Non-blocking
	{
		return 0;
	} 
	else {
		return 1;
	}
}


/**
 * Fonction de lecture de la température via un capteur DS18B20.
 */
byte getTemperature(float *temperature, byte reset_search) {
  byte data[9], addr[8];
  // data[] : Données lues depuis le scratchpad
  // addr[] : Adresse du module 1-Wire détecté
  
  /* Reset le bus 1-Wire ci nécessaire (requis pour la lecture du premier capteur) */
  if (reset_search) {
    ds.reset_search();
  }
 
  /* Recherche le prochain capteur 1-Wire disponible */
  if (!ds.search(addr)) {
    // Pas de capteur
    return NO_SENSOR_FOUND;
  }
  
  /* Vérifie que l'adresse a été correctement reçue */
  if (OneWire::crc8(addr, 7) != addr[7]) {
    // Adresse invalide
    return INVALID_ADDRESS;
  }
 
  /* Vérifie qu'il s'agit bien d'un DS18B20 */
  if (addr[0] != 0x28) {
    // Mauvais type de capteur
    return INVALID_SENSOR;
  }
 
  /* Reset le bus 1-Wire et sélectionne le capteur */
  ds.reset();
  ds.select(addr);
  
  /* Lance une prise de mesure de température et attend la fin de la mesure */
  ds.write(0x44, 1);
  delay(800);
  
  /* Reset le bus 1-Wire, sélectionne le capteur et envoie une demande de lecture du scratchpad */
  ds.reset();
  ds.select(addr);
  ds.write(0xBE);
 
 /* Lecture du scratchpad */
  for (byte i = 0; i < 9; i++) {
    data[i] = ds.read();
  }
   
  /* Calcul de la température en degré Celsius */
  *temperature = (int16_t) ((data[1] << 8) | data[0]) * 0.0625; 
  
  // Pas d'erreur
  return READ_OK;
}



